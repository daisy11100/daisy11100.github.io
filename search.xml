<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端常见面试题--第一弹]]></title>
    <url>%2Fdaisy11100.github.io%2F2019%2F07%2F19%2F%E4%B8%80%2F</url>
    <content type="text"><![CDATA[一、css盒模型1、基本概念：css的盒模型本质是一个盒子，封装周围的HTML元素，包括：外边距、边框、内边距和实际内容。 Margin（外边距）：边框以外的区域，外边距是透明的 Border(边框)：围绕在内边距和内容外的边框 Padding（内边距）：内容与边框之间的区域，内边距是透明的 Content（内容）：盒子的内容 2、标准盒模型和IE盒模型区别：标准盒模型和IE盒模型的width和height的计算方式不同 举个栗子：假设设置一个元素宽高各为100px，为了方便观察设置背景色为red，代码如下： 123456789101112 #div1{ width: 100px; height: 100px; background-color: red; padding: 10px; } 盒模型 然后在浏览器审查元素的时候你就会发现，元素的大小并不是自己设置的100px，而是变成了120px。 这是因为在默认情况下的盒模型是标准盒模型，设置的width、heigh仅仅只是内容的宽高，不包含padding、border等；所以在添加了padding之后自然整体宽高都会变大，不是自己之前设置的了。 标准盒模型的定义的width指的是content-width， IE盒模型定义的width指 border+padding+content-width 设置： 标准模型（默认）box-sizing：content-box IE盒模型 box-sizing：border-box 二、link和@import的区别1、首先来说一下link和@import是用来干什么的，在HTML中引入css的方式有四种： 内联方式：直接在HTML标签中style属性中添加css样式 1 嵌入方式：在HTML头部中的style标签中写下css代码 12345 .content {background: red;} 链接方式：在HTML头部的标签中引入外部css文件 123 导入方式：是指使用css规则引入外部css文件 123 @import url(style.css); 所以link和@import是将css引入HTML中的方式，虽然都是css引入方式，但是可能对大家而言link比较熟悉，使用的次数比较多，相比之下@import就很少被使用。为什么都是导入方式大家都喜欢用link，而不是@import，这就要看一下他两之间的区别了。 2、区别： 加载方式不同，link可以在页面载入的同时进行加载，而@import只能在页面加载完成之后才能进行加载。 link属于HTML，不存在兼容问题，@import是css2.1才提出的概念，所以浏览器版本较低时可能就无法正确导入外部样式文件。 @import是css提供的语法规则，只有导入样式表的作用，而link属于html，不仅可以导入样式表，还可以定义rel等属性。 link支持使用JavaScript来改变DOM样式，@import不支持 三、绑定事件的三种方式1、DOM元素直接绑定，简单来说就是在html标签中绑定事件的话，需要在js中写上事件处理的程序，然后在html中使用同名的html特性来调用。 123456clickme function messageShow(){ alert("Yes"); } 2、在js中绑定事件，这是我们最常用的一种绑定事件的方式，先获取到html元素，再在js里绑定事件 1234567clickMe var oBtn=document.getElementsByTagName("button")[0]; oBtn.onclick=function(){ alert('Yes1'); } 3、使用事件监听绑定事件 123456789clickMe var oBtn=document.getElementsByTagName("button")[0]; // 给元素绑定事件监听函数 oBtn.addEventListener('click',function(){ alert(this.type); },false) var Show=function(){ alert('OK!'); }; 需要注意的是使用事件监听绑定事件时，有三个参数，addEventListener（事件名，事件处理程序，布尔值），最后一个参数是布尔值，如果是true，表示在捕获阶段调用事件处理程序，如果是false，表示在冒泡阶段调用事件处理程序，一般都是false。 四、typeof和instance的区别 基本数据类型：number、string、Boolean、undefined、null 引用数据类型：object 1、typeof typeof可以检测给定变量的数据类型，返回值为一个字符串，可能是number、boolean、string、function、undefined、object。 123console.log(typeof(Array)); //"function"console.log(typeof(Object)); //"function"console.log(typeof(null)); //"Object" 要注意以上三种情况，Array和Object的数据类型是function，因为Array本身就是js内部创建的构造函数。null是指空对象，所以输出来为Object类型。 typeof一般用来判断一个变量是否存在： 123if(typeof(a)!="undefined"){ console.log("ok"); } 如果存在的话返回ok。 2、instanceofinstanceof的作用是判断一个变量是否是某一个对象的实例，A instanceof B（判断A是否是B的实例，是的话返回true，不是的话返回去false）。 12345var a=new Array; console.log(a instanceof Array); //"true" console.log(Array instanceof Function); //"true" console.log(Object instanceof Function);//"true" console.log(a instanceof Function);//"true" 上面的例子也证明了typeof的输出结果，Array和Object是Function的实例，所以检测出来Array和Object的数据类型为function。 因为Array是function的实例，而a又是Array的实例，所以a就是Function的实例，a instanceof Function会返回一个true。 五、src和herf的区别 src是将指定资源嵌套进当前文档 herf是在当前文档和指定资源之间开辟了一条通道 六、从输入一个url开始，到页面加载完成，都会发生哪些操作？1、DNS解析DNS（域名解析）实现了网址到IP地址的转换，通过主机名，获取到与主机名相对应的ip地址。其实就是一个递归查询到过程，从本地域名->根域名->顶级域名，比如com->google.com->www.google.com 2、TCP连接（三握四挥） 发送http请求 发送http请求就是构建http请求报文，并通过TCP协议发送到服务器的指定端口（http是8080，https包括）。 http请求报文一般包括请求方式、请求报头、请求正文 请求行：Method Request-URL HTTP-Version CRLF ​ eg: GET index.html HTTP/1.1 ​ 常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。 2.服务器响应请求并返回http报文 ​ http响应报文由三部分组成：状态码、响应报头、响应报文 ​ 状态码： 1××：指示信息-表示请求已接收，继续处理 2××：成功-表示请求已经成功接收、理解、接受 3××：重定向-表示要完成请求必须进行更近一步的操作 4××：客户端错误-请求有语法错误或者请求无法实现 5××：服务器错误-服务器无法完成合法的请求 3、浏览器解析并渲染页面 解析html文档，构建DOM树。 下载css文件，开始构建css树。 css树构建完成之后，和DOM树一起构成渲染树。 布局：计算出每个节点在页面中的位置。 显示，通过显卡显示页面 DOM树和渲染树的区别： DOM树与HTML标签一一对应，包括head和隐藏的节点 渲染树不包括head和隐藏的元素，并且每个节点都有与之对应的css样式。 重绘和重排（这个也需要划重点）： 当页面中的元素样式发生变化时（颜色等），不影响节点的布局时，会引起浏览器的重绘 当页面中的DOM元素的位置，尺寸等影响布局的样式发生变化时，会引起浏览器的重排 重排一定会引发重绘 但是重绘不一定能引起重排 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2Fdaisy11100.github.io%2F2019%2F07%2F10%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[1、变量作用域 要理解闭包，首先要理解javascript的特殊的变量作用域。 变量的作用域无非就两种：全局变量和局部变量。 javascript语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。 注意点：在函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明的是一个全局变量！ 2、如何从外部读取函数内部的局部变量？ 出于种种原因，我们有时候需要获取到函数内部的局部变量。但是，上面已经说过了，正常情况下，这是办不到的！只有通过变通的方法才能实现。 那就是在函数内部，再定义一个函数。 function f1(){ var n=999; function f2(){ alert(n); // 999 } } 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。 这就是Javascript语言特有的”链式作用域”结构（chain scope）， 子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 3、闭包的概念 上面代码中的f2函数，就是闭包。 各种专业文献的闭包定义都非常抽象，我的理解是: 闭包就是能够读取其他函数内部变量的函数。 由于在javascript中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成“定义在一个函数内部的函数“。 所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。 4、闭包的用途 闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 5、使用闭包的注意点 （1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 （2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[水平垂直居中的方法]]></title>
    <url>%2Fdaisy11100.github.io%2F2019%2F07%2F10%2F%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[宽度高度未知，纯定位 1234567891011position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto； 定位+负的margin，宽高未知 1234567position: absolute; top: 50%; margin-left: -50px; margin-top: -50px flex布局，宽高要已知 12345678910111213body{ display: flex; width: 100%; height: 500px; justify-content: center; align-items: center; } 定位+transform 1234567position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); translate方法中的-50%是自身的50%，所以其实这个方法和marign负值相似。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
</search>
