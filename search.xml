<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[理解词法作用域和动态作用域]]></title>
    <url>%2Fdaisy11100.github.io%2F2019%2F08%2F14%2F81401%2F</url>
    <content type="text"><![CDATA[1、词法作用域，函数的作用域在函数定义的时候就决定了（作用域由定义时的位置决定） 2、动态作用域，函数的作用域在函数调用的时候就决定了 3、JavaScript采用的是词法作用域 123456789101112var value=1; function foo(){ console.log(value); } function bar(){ var value=2; foo(); } bar();//1 4、 词法作用域解释：bar()函数调用foo()函数， foo内部没有value，就根据作用域链向上找，找到全局定义的value等于1. 动态作用域解释：bar()函数调用foo()函数， foo内部没有value，就在调用函数bar的内部查找value变量，这时就找到局部定义的value等于2 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包的实现原理和作用]]></title>
    <url>%2Fdaisy11100.github.io%2F2019%2F08%2F14%2F814%2F</url>
    <content type="text"><![CDATA[一、闭包的实现原理和作用，可以列举几个开发中闭包的实际应用1、闭包的概念：指有权访问另一个函数作用域中的变量的函数，一般情况就是在一个函数中包含另一个函数。 2、闭包的作用：访问函数内部变量、保持函数在环境中一直存在，不会被垃圾回收机制处理 因为函数内部声明 的变量是局部的，只能在函数内部访问到，但是函数外部的变量是对函数内部可见的，这就是作用域链的特点了。 子级可以向父级查找变量，逐级查找，找到为止 因此我们可以在函数内部再创建一个函数，这样对内部的函数来说，外层函数的变量都是可见的，然后我们就可以访问到他的变量了。 12345678910111213 function bar(){ //外层函数声明的变量 var value=1; function foo(){ console.log(value); } return foo(); }; var bar2=bar; //实际上bar()函数并没有因为执行完就被垃圾回收机制处理掉 //这就是闭包的作用，调用bar()函数，就会执行里面的foo函数，foo这时就会访问到外层的变量bar2(); foo（）包含bar（）内部作用域的闭包，使得该作用域能够一直存活，不会被垃圾回收机制处理掉，这就是闭包的作用，以供foo（）在任何时间进行引用。 3、闭包的优点： 方便调用上下文中声明的局部变量 逻辑紧密，可以在一个函数中再创建个函数，避免了传参的问题 4、闭包的缺点： 因为使用闭包，可以使函数在执行完后不被销毁，保留在内存中，如果大量使用闭包就会造成内存泄露，内存消耗很大 5、闭包在实际中的应用 1234567function addFn(a,b){ return(function(){ console.log(a+"+"+b); }) } var test =addFn(a,b); setTimeout(test,3000); 一般setTimeout的第一个参数是个函数，但是不能传值。如果想传值进去，可以调用一个函数返回一个内部函数的调用，将内部函数的调用传给setTimeout。内部函数执行所需的参数，外部函数传给他，在setTimeout函数中也可以访问到外部函数。 二、理解堆栈溢出和内存泄漏的原理，如何防止1、内存泄露：是指申请的内存执行完后没有及时的清理或者销毁，占用空闲内存，内存泄露过多的话，就会导致后面的程序申请不到内存。因此内存泄露会导致内部内存溢出 2、堆栈溢出：是指内存空间已经被申请完，没有足够的内存提供了 3、在一些编程软件中，比如c语言中，需要使用malloc来申请内存空间，再使用free释放掉，需要手动清除。而js中是有自己的垃圾回收机制的，一般常用的垃圾收集方法就是标记清除。 标记清除法：在一个变量进入执行环境后就给它添加一个标记：进入环境，进入环境的变量不会被释放，因为只要执行流进入响应的环境，就可能用到他们。当变量离开环境后，则将其标记为“离开环境”。 4、常见的内存泄露的原因 全局变量引起的内存泄露 闭包 没有被清除的计时器 5、解决方法 减少不必要的全局变量 减少闭包的使用（因为闭包会导致内存泄露） 避免死循环的发生 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中如何使用swiper]]></title>
    <url>%2Fdaisy11100.github.io%2F2019%2F08%2F03%2F803%2F</url>
    <content type="text"><![CDATA[在vue-cli中如何使用swiper插件做轮播图 第一次使用可能会有点摸不透，但是通过相互之间的对比，并且在了解生命周期函数之后，并没有什么难的。 一、不使用框架的情况下 这是swiper官方给出的使用方法 分为了四部分： 1.首先加载插件，需要用到的文件有swiper.min.js和swiper.min.css文件 123456789101112 ... ... ... 2.HTML内容。 12345678910111213141516 Slide 1 Slide 2 Slide 3 3.你可能想要给Swiper定义一个大小，当然不要也行。 1234.swiper-container { width: 600px; height: 300px; } 4.初始化Swiper：最好是挨着标签 1234567891011121314151617181920212223 var mySwiper = new Swiper ('.swiper-container', { direction: 'vertical', // 垂直切换选项 loop: true, // 循环模式选项 // 如果需要分页器 pagination: { el: '.swiper-pagination', }, // 如果需要前进后退按钮 navigation: { nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev', }, // 如果需要滚动条 scrollbar: { el: '.swiper-scrollbar', }, }) 二、在vue中使用swiper 因此，在vue-cli 中使用swiper也是同样的步骤，只不过有些稍微的改动，可以对比记忆更方便。 1、把之前直接引入swiper.min.js的方式改为，在项目文件下使用npm i swiper安装 1npm i swiper 2、把swiper.min.css下载然后拷贝到脚手架assets文件夹下 3、 js中引入swiper.min.js， style中引入swiper.min.css， template中放入原本放入html中的代码 1234567891011import Swiper from "swiper"export default { name:"swiperpic", data:function(){ return { } },} 1234567@import"../../assets/swiper.css";//后跟的是swiper.css的相对路径.swiper-container{ width: 359px; height: 172px; } 12345678910111213141516171819 Slide 1 Slide 2 Slide 3 4、将初始化Swiper的代码，放入mounte生命周期函数中，因为要操作DOM，而只有挂载后才能获取到DOM元素。 123456789101112131415161718192021222324252627282930313233import Swiper from "swiper"export default { name:"swiperpic", data:function(){ return { } }, mounted:function(){ var mySwiper = new Swiper ('.swiper-container', { direction: 'vertical', // 垂直切换选项 loop: true, // 循环模式选项 // 如果需要分页器 pagination: { el: '.swiper-pagination', }, // 如果需要前进后退按钮 navigation: { nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev', }, // 如果需要滚动条 scrollbar: { el: '.swiper-scrollbar', }, }) }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue生命周期]]></title>
    <url>%2Fdaisy11100.github.io%2F2019%2F07%2F25%2Fvue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[关于vue生命周期这块，官方给的图自己也是看了很久，但是也没看出来个啥。。。后来就看视频学习，看完视频后才明白原来官方就是官方，给的图看起来很繁琐但是理解了之后就会发现都是有逻辑在里面的，简洁又不失逻辑。下面是自己在学习vue生命周期的一些学习总结。 beforeCreated： 初始化了一个空的Vue实例对象，只有一些默认的生命周期函数和默认事件 123456789101112131415var vm = new Vue({ el:"#app", data:{ msg:"hello", }, methods:{ show:function(){ console.log("show函数可以被调用了"); } }, beforeCreate(){ // 在beforeCreate生命周期函数中，data中的数据和methods中的方法都还没有被初始化 console.log(this.msg); this.show(); },}) 此时vue对象中的属性和methods还没被初始化，所以在这个生命周期函数中无法获取到data中的数据和methods中的方法。 2.created： 初始化属性和methods，data中的数据和methods中的方法在这个阶段后就可以获取到了。 12345created(){ // 在created生命周期函数中，data中的数据和methods中的方法被初始化了，如果想操作data中的数据和方法，最早只能在created中操作 console.log(this.msg); this.show(); }, 再到created生命周期函数中执行一下刚才在beforeCreate中的代码，结果显示调用成功，表示这时候vue实例的属性和methods已经初始化了。 3.beforeMount： 挂载前调用，vue开始编译模版，在内存中生成一个最终编译好的模版字符串，然后把这个模版字符串渲染成内存中的DOM，但是这个模版是存在于DOM中的，并没有挂载到真正的页面上， 123456 //js beforeMount(){ // 模版已经在内存中编辑好了，但是并未渲染到页面 // 在beforeMount执行的时候，页面中的元素还没有真正的被替换过来 console.log(document.getElementById("h1").innerText); }, document.getElementById(“h1”).innerText的结果还是，表示页面上的内容实际上还没更改，因此但是这个模版是存在于DOM中的，并没有挂载到真正的页面上 4.mounted： 调用将内存中编辑好的模版渲染到页面上，实现挂载，mounted是实例创建期间的最后一个生命周期函数，到此为止，实例已经被完全创建 1234mounted(){ //将内存中编辑好的模版渲染到页面上，实现挂载 // mounted是实例创建期间最后一个生命周期函数，到此为止，实例就被完全创建了， console.log(document.getElementById("h1").innerText); }, 同样的我们将beforeMount函数中的代码放到mounted函数中再次执行，结果显示，页面上的h1标签中的msg已经被渲染，和data中的一致。这个阶段，将上一阶段在内存中编译好的模版渲染到页面上。 5.beforeUpdate： 组件运行前后的生命周期函数，更新前调用。会根据数据的改变调用，当执行beforeUpdate函数时data中的数据已经更新，但是页面上的数据还是旧的，所以此时页面和data中的数据没有同步， 123456beforeUpdate(){ //页面中h1标签中的内容 console.log(document.getElementById("h1").innerText); //data中的数据 console.log(this.msg); }, 结果表明在beforeUpdate这个阶段，当data中数据发生改变时，页面中的数据不会跟data中的数据同步。 updated：更新后调用，页面和data数据实现一致 123456updated(){ //页面中h1标签中的内容 //data中的数据 console.log(document.getElementById("h1").innerText); console.log(this.msg); }, 我们再把beforeUpdate函数中的代码放到Updated函数中执行，结果如上图所示，表示页面中的数据和data中的数据实现同步了。 beforeDestory： 实例销毁前调用，主要解绑一些监听事件等。执行beforeDestory函数时，就开始从执行阶段到销毁阶段了 destoryed： 销毁后，数据，方法、指令已经被完全销毁 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端常见面试题--第一弹]]></title>
    <url>%2Fdaisy11100.github.io%2F2019%2F07%2F19%2F%E4%B8%80%2F</url>
    <content type="text"><![CDATA[一、css盒模型1、基本概念：css的盒模型本质是一个盒子，封装周围的HTML元素，包括：外边距、边框、内边距和实际内容。 Margin（外边距）：边框以外的区域，外边距是透明的 Border(边框)：围绕在内边距和内容外的边框 Padding（内边距）：内容与边框之间的区域，内边距是透明的 Content（内容）：盒子的内容 2、标准盒模型和IE盒模型区别：标准盒模型和IE盒模型的width和height的计算方式不同 举个栗子：假设设置一个元素宽高各为100px，为了方便观察设置背景色为red，代码如下： 123456789101112 #div1{ width: 100px; height: 100px; background-color: red; padding: 10px; } 盒模型 然后在浏览器审查元素的时候你就会发现，元素的大小并不是自己设置的100px，而是变成了120px。 这是因为在默认情况下的盒模型是标准盒模型，设置的width、heigh仅仅只是内容的宽高，不包含padding、border等；所以在添加了padding之后自然整体宽高都会变大，不是自己之前设置的了。 标准盒模型的定义的width指的是content-width， IE盒模型定义的width指 border+padding+content-width 设置： 标准模型（默认）box-sizing：content-box IE盒模型 box-sizing：border-box 二、link和@import的区别1、首先来说一下link和@import是用来干什么的，在HTML中引入css的方式有四种： 内联方式：直接在HTML标签中style属性中添加css样式 1 嵌入方式：在HTML头部中的style标签中写下css代码 12345 .content {background: red;} 链接方式：在HTML头部的标签中引入外部css文件 123 导入方式：是指使用css规则引入外部css文件 123 @import url(style.css); 所以link和@import是将css引入HTML中的方式，虽然都是css引入方式，但是可能对大家而言link比较熟悉，使用的次数比较多，相比之下@import就很少被使用。为什么都是导入方式大家都喜欢用link，而不是@import，这就要看一下他两之间的区别了。 2、区别： 加载方式不同，link可以在页面载入的同时进行加载，而@import只能在页面加载完成之后才能进行加载。 link属于HTML，不存在兼容问题，@import是css2.1才提出的概念，所以浏览器版本较低时可能就无法正确导入外部样式文件。 @import是css提供的语法规则，只有导入样式表的作用，而link属于html，不仅可以导入样式表，还可以定义rel等属性。 link支持使用JavaScript来改变DOM样式，@import不支持 三、绑定事件的三种方式1、DOM元素直接绑定，简单来说就是在html标签中绑定事件的话，需要在js中写上事件处理的程序，然后在html中使用同名的html特性来调用。 123456clickme function messageShow(){ alert("Yes"); } 2、在js中绑定事件，这是我们最常用的一种绑定事件的方式，先获取到html元素，再在js里绑定事件 1234567clickMe var oBtn=document.getElementsByTagName("button")[0]; oBtn.onclick=function(){ alert('Yes1'); } 3、使用事件监听绑定事件 123456789clickMe var oBtn=document.getElementsByTagName("button")[0]; // 给元素绑定事件监听函数 oBtn.addEventListener('click',function(){ alert(this.type); },false) var Show=function(){ alert('OK!'); }; 需要注意的是使用事件监听绑定事件时，有三个参数，addEventListener（事件名，事件处理程序，布尔值），最后一个参数是布尔值，如果是true，表示在捕获阶段调用事件处理程序，如果是false，表示在冒泡阶段调用事件处理程序，一般都是false。 四、typeof和instance的区别 基本数据类型：number、string、Boolean、undefined、null 引用数据类型：object 1、typeof typeof可以检测给定变量的数据类型，返回值为一个字符串，可能是number、boolean、string、function、undefined、object。 123console.log(typeof(Array)); //"function"console.log(typeof(Object)); //"function"console.log(typeof(null)); //"Object" 要注意以上三种情况，Array和Object的数据类型是function，因为Array本身就是js内部创建的构造函数。null是指空对象，所以输出来为Object类型。 typeof一般用来判断一个变量是否存在： 123if(typeof(a)!="undefined"){ console.log("ok"); } 如果存在的话返回ok。 2、instanceofinstanceof的作用是判断一个变量是否是某一个对象的实例，A instanceof B（判断A是否是B的实例，是的话返回true，不是的话返回去false）。 12345var a=new Array; console.log(a instanceof Array); //"true" console.log(Array instanceof Function); //"true" console.log(Object instanceof Function);//"true" console.log(a instanceof Function);//"true" 上面的例子也证明了typeof的输出结果，Array和Object是Function的实例，所以检测出来Array和Object的数据类型为function。 因为Array是function的实例，而a又是Array的实例，所以a就是Function的实例，a instanceof Function会返回一个true。 五、src和herf的区别 src是将指定资源嵌套进当前文档 herf是在当前文档和指定资源之间开辟了一条通道 六、从输入一个url开始，到页面加载完成，都会发生哪些操作？1、DNS解析DNS（域名解析）实现了网址到IP地址的转换，通过主机名，获取到与主机名相对应的ip地址。其实就是一个递归查询到过程，从本地域名->根域名->顶级域名，比如com->google.com->www.google.com 2、TCP连接（三握四挥） 发送http请求 发送http请求就是构建http请求报文，并通过TCP协议发送到服务器的指定端口（http是8080，https包括）。 http请求报文一般包括请求方式、请求报头、请求正文 请求行：Method Request-URL HTTP-Version CRLF ​ eg: GET index.html HTTP/1.1 ​ 常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。 2.服务器响应请求并返回http报文 ​ http响应报文由三部分组成：状态码、响应报头、响应报文 ​ 状态码： 1××：指示信息-表示请求已接收，继续处理 2××：成功-表示请求已经成功接收、理解、接受 3××：重定向-表示要完成请求必须进行更近一步的操作 4××：客户端错误-请求有语法错误或者请求无法实现 5××：服务器错误-服务器无法完成合法的请求 3、浏览器解析并渲染页面 解析html文档，构建DOM树。 下载css文件，开始构建css树。 css树构建完成之后，和DOM树一起构成渲染树。 布局：计算出每个节点在页面中的位置。 显示，通过显卡显示页面 DOM树和渲染树的区别： DOM树与HTML标签一一对应，包括head和隐藏的节点 渲染树不包括head和隐藏的元素，并且每个节点都有与之对应的css样式。 重绘和重排（这个也需要划重点）： 当页面中的元素样式发生变化时（颜色等），不影响节点的布局时，会引起浏览器的重绘 当页面中的DOM元素的位置，尺寸等影响布局的样式发生变化时，会引起浏览器的重排 重排一定会引发重绘 但是重绘不一定能引起重排 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
  </entry>
  <entry>
    <title><![CDATA[水平垂直居中的方法]]></title>
    <url>%2Fdaisy11100.github.io%2F2019%2F07%2F10%2F%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[宽度高度未知，纯定位 1234567891011position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto； 定位+负的margin，宽高未知 1234567position: absolute; top: 50%; margin-left: -50px; margin-top: -50px flex布局，宽高要已知 12345678910111213body{ display: flex; width: 100%; height: 500px; justify-content: center; align-items: center; } 定位+transform 1234567position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); translate方法中的-50%是自身的50%，所以其实这个方法和marign负值相似。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
</search>
